// generated by koffee 0.24.0

/*
00     00  00000000  000000000   0000000   
000   000  000          000     000   000  
000000000  0000000      000     000000000  
000 0 000  000          000     000   000  
000   000  00000000     000     000   000
 */

(function() {
    var META, TAB, compileMetaIf, injectMeta, logMetas;

    META = [
        {
            key: 'profile',
            desc: '@profile [id] ...',
            info: {
                args: 1
            },
            meta: function(arg) {
                var args, id, name, node, ref, ref1, ref2;
                args = (ref = arg.args) != null ? ref : null, node = (ref1 = arg.node) != null ? ref1 : null;
                id = (node.condition.locationData.first_line + 1) + "_" + node.condition.locationData.first_column;
                name = (ref2 = args[0]) != null ? ref2 : id;
                return {
                    after: "console.log('" + name + "', require('pretty-time')(process.hrtime(koffee_" + id + ")));",
                    code: "koffee_" + id + " = process.hrtime()",
                    reduce: false,
                    body: true
                };
            }
        }, {
            key: 'start',
            desc: '@start id ...',
            info: {
                then: true,
                args: 1
            },
            meta: function(arg) {
                var args, id, ref, ref1;
                args = (ref = arg.args) != null ? ref : null;
                id = (ref1 = args[0]) != null ? ref1 : 'start_end';
                return {
                    before: "koffee_" + id + " = process.hrtime()",
                    reduce: true,
                    body: false
                };
            }
        }, {
            key: 'end',
            desc: '@end id ...',
            info: {
                then: true,
                args: 1
            },
            meta: function(arg) {
                var args, id, ref, ref1;
                args = (ref = arg.args) != null ? ref : null;
                id = (ref1 = args[0]) != null ? ref1 : 'start_end';
                return {
                    before: "console.log('" + id + "', require('pretty-time')(process.hrtime(koffee_" + id + ")))",
                    reduce: true,
                    body: false
                };
            }
        }, {
            key: 'dbg',
            desc: '@dbg msg ...',
            info: {
                then: true,
                args: 1
            },
            meta: function(arg) {
                var args, before, node, opts, ref, ref1, ref2;
                opts = (ref = arg.opts) != null ? ref : null, args = (ref1 = arg.args) != null ? ref1 : null, node = (ref2 = arg.node) != null ? ref2 : null;
                before = "console.log('" + (require('path').basename(opts.source)) + ":" + (node.condition.locationData.first_line + 1) + "'";
                if (args[0]) {
                    before += ", '" + args[0] + "'";
                }
                before += ", ";
                return {
                    code: "o.Debug",
                    "eval": true,
                    before: before,
                    after: ")",
                    reduce: true,
                    block: false
                };
            }
        }, {
            key: 'rand',
            meta: function(arg) {
                var args, ref, ref1;
                args = (ref = arg.args) != null ? ref : null;
                return {
                    code: "Math.random() < " + ((ref1 = args != null ? args[0] : void 0) != null ? ref1 : 0.5),
                    reduce: false,
                    body: true
                };
            }
        }
    ];

    TAB = '    ';

    compileMetaIf = function(arg) {
        var args, body, bodyOpt, cond, err, frag, fs, indent, info, metaKey, node, opts, os, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9;
        node = (ref = arg.node) != null ? ref : null, opts = (ref1 = arg.opts) != null ? ref1 : null;
        info = {
            reduce: true
        };
        if (((ref2 = node.condition.base) != null ? ref2.value : void 0) === 'this') {
            metaKey = (ref3 = node.condition.properties) != null ? (ref4 = ref3[0]) != null ? (ref5 = ref4.name) != null ? ref5.value : void 0 : void 0 : void 0;
            if (typeof opts.meta[metaKey] === 'function') {
                info = opts.meta[metaKey]({
                    opts: opts,
                    node: node,
                    args: []
                });
            }
        } else if (((ref6 = node.condition.variable) != null ? (ref7 = ref6.base) != null ? ref7.value : void 0 : void 0) === 'this') {
            metaKey = (ref8 = node.condition.variable.properties) != null ? (ref9 = ref8[0]) != null ? (ref10 = ref9.name) != null ? ref10.value : void 0 : void 0 : void 0;
            if (typeof opts.meta[metaKey] === 'function') {
                args = node.condition.args.map(function(a) {
                    var ref11;
                    return (ref11 = a.base) != null ? ref11.value : void 0;
                });
                args = args.map(function(a) {
                    var ref11;
                    if ((ref11 = a[0]) === '"' || ref11 === "'") {
                        return a.slice(1, -1);
                    } else {
                        return a;
                    }
                });
                info = opts.meta[metaKey]({
                    opts: opts,
                    node: node,
                    args: args
                });
            }
        }
        if (info["eval"] || (info.code == null)) {
            cond = (ref11 = info.code) != null ? ref11 : node.fragmentsToText(node.condition.compileToFragments(opts, 2));
            try {
                os = require('os');
                fs = require('fs');
                info.body = !!eval(cond);
                if (info["eval"] && info.reduce && !info.body && !node.elseBody) {
                    return [];
                }
            } catch (error) {
                err = error;
                console.error(err);
            }
        }
        frag = [];
        if (info.reduce === false) {
            frag = frag.concat(node.makeCode("if ("), node.makeCode(info.code), node.makeCode(") {\n"));
            indent = opts.indent + TAB;
            bodyOpt = merge(opts, {
                indent: indent
            });
        } else {
            indent = opts.indent;
            bodyOpt = opts;
        }
        if (info.before) {
            if (info.block === false) {
                frag.push(node.makeCode(info.before));
            } else {
                frag.push(node.makeCode(indent + info.before));
            }
        }
        if (info.body) {
            if (info.block !== false) {
                body = node.ensureBlock(node.body);
            } else {
                if (node.body instanceof Block) {
                    body = node.body.expressions[0];
                } else {
                    body = node.body;
                }
            }
            frag = frag.concat(body.compileToFragments(bodyOpt));
        }
        if (info.after) {
            if (info.block === false) {
                frag.push(node.makeCode(info.after));
            } else {
                frag.push(node.makeCode('\n' + indent + info.after));
            }
        }
        if (!info.reduce) {
            frag.push(node.makeCode("\n" + node.tab + "}"));
        }
        if (node.elseBody && (info.reduce === false || info.body === false)) {
            if (!info.reduce) {
                frag.push(node.makeCode(' else '));
            }
            if (node.isChain) {
                frag = frag.concat(node.elseBody.unwrap().compileToFragments(bodyOpt, 1));
            } else {
                frag = frag.concat(node.elseBody.compileToFragments(bodyOpt));
            }
        }
        return frag;
    };

    injectMeta = function(options) {
        var defaultMeta, extend, meta, ref;
        if (options != null) {
            options;
        } else {
            options = {};
        }
        extend = require('./helpers').extend;
        defaultMeta = {};
        META.map(function(m) {
            defaultMeta[m.key] = m.meta;
            m.meta.key = m.key;
            return m.meta.info = m.info;
        });
        meta = extend(defaultMeta, (ref = options.meta) != null ? ref : {});
        options = extend({
            meta: meta
        }, options);
        return options;
    };

    logMetas = function() {
        var gray, pad;
        pad = require('./helpers').pad;
        gray = require('colorette').gray;
        console.log((gray('Metas:')) + "\n\n" + (META.map(function(f) {
            var ref;
            return "    " + (pad(f.key)) + (gray((ref = f.desc) != null ? ref : "@" + f.key + " ..."));
        }).join('\n')));
        return console.log("    if else                 " + (gray('@if cond ... [[@elif cond ...] @else ...]')) + "\n");
    };

    module.exports = {
        META: META,
        injectMeta: injectMeta,
        logMetas: logMetas,
        compileMetaIf: compileMetaIf
    };

}).call(this);
