// Generated by koffee 0.4.0

/*
 0000000   0000000   00     00  00     00   0000000   000   000  0000000    
000       000   000  000   000  000   000  000   000  0000  000  000   000  
000       000   000  000000000  000000000  000000000  000 0 000  000   000  
000       000   000  000 0 000  000 0 000  000   000  000  0000  000   000  
 0000000   0000000   000   000  000   000  000   000  000   000  0000000
 */

(function() {
    var BANNER, EventEmitter, FEATURES, Koffee, SWITCHES, compileOptions, compilePath, compileScript, compileStdio, error, exec, features, findDirectoryIndex, fs, helpers, hidden, log, makePrelude, mkdirp, nopt, opts, outputPath, parseOptions, path, print, printLine, printTokens, printWarn, ref, run, spawn, startRepl, timeLog, usage, useWinPathSep, version, wait, watchDir, watchFile, watchPath, writeJs;

    fs = require('fs');

    path = require('path');

    nopt = require('nopt');

    helpers = require('./helpers');

    Koffee = require('./koffee');

    ref = require('child_process'), spawn = ref.spawn, exec = ref.exec;

    EventEmitter = require('events').EventEmitter;

    useWinPathSep = path.sep === '\\';

    helpers.extend(Koffee, new EventEmitter);

    log = console.log;

    error = console.error;

    print = function(line) {
        return process.stdout.write(line);
    };

    printLine = function(line) {
        return process.stdout.write(line + '\n');
    };

    printWarn = function(line) {
        return process.stderr.write(line + '\n');
    };

    hidden = function(file) {
        return /^\.|~$/.test(file);
    };

    BANNER = "Usage: koffee [options] path/to/script -- [args]";

    FEATURES = [['header', 'prefix with "Generated by" header'], ['rewrite', 'rewrite tokens'], ['config-parameters', 'enable config parameters'], ['constructor-shortcut', 'replace @: with constructor:'], ['negative-index', 'replace a[-1] with a[-1..-1]']];

    SWITCHES = [['-b', '--bare', 'compile without a top-level function wrapper', Boolean], ['-c', '--compile', 'compile to JavaScript and save as .js files', Boolean], ['-e', '--eval [STRING]', 'pass a string from the command line as input', [String, Array]], ['-f', '--features', 'list available features', Boolean], ['', '--no-[feature]', 'disable a feature, e.g. --no-negative-index', null], ['-h', '--help', 'display this help message', Boolean], ['-j', '--js', 'print out the compiled JavaScript', Boolean], ['-m', '--map', 'generate source map and save as .js.map files', Boolean], ['-M', '--inline-map', 'generate source map and include it directly in output', Boolean], ['-n', '--noop', 'does nothing, for debugging purposes', Boolean], ['-o', '--output [DIR]', 'set the output directory for compiled JavaScript', String], ['-p', '--parse', 'print out the parse tree that the parser produces', Boolean], ['-r', '--require [MODULE]', 'require the given module before eval or REPL', [String, Array]], ['-s', '--stdio', 'listen for and compile scripts over stdio', Boolean], ['-t', '--tokens', 'print out the tokens that the lexer/rewriter produce', Boolean], ['-v', '--version', 'display the version number', Boolean], ['-w', '--watch', 'watch scripts for changes and rerun commands', Boolean]];

    opts = {};

    parseOptions = function() {
        var known, o, short, toggles;
        toggles = ['bare', 'compile', 'features', 'help', 'inline-map', 'js', 'map', 'parse', 'stdio', 'tokens', 'version', 'watch', 'Debug'];
        known = {
            Debug: Boolean
        };
        short = {
            D: '--Debug'
        };
        SWITCHES.map(function(s) {
            var l;
            l = s[1].split(' ')[0].slice(2);
            if (s[3]) {
                known[l] = s[3];
            }
            if (s[0] !== '') {
                return short[s[0][1]] = "--" + l;
            }
        });
        FEATURES.map(function(f) {
            return known[f[0]] = Boolean;
        });
        o = opts = nopt(known, short);
        o.compile || (o.compile = !!o.output);
        o["arguments"] = o.argv.remain;
        o.run = !(o.compile || o.js || o.map || o.tokens || o.parse);
        o.js = !!(o.js || o["eval"] || o.stdio && o.compile);
        o.feature = {};
        FEATURES.map(function(f) {
            var ref1;
            o.feature[f[0]] = (ref1 = o[f[0]]) != null ? ref1 : true;
            return delete o[f[0]];
        });
        if (o.Debug) {
            delete o.argv;
            return log(helpers.stringify(o));
        }
    };

    run = function() {
        var eval, i, j, len, len1, literals, ref1, ref2, results, source;
        parseOptions();
        if (opts.features) {
            return features();
        }
        if (opts.help) {
            return usage();
        }
        if (opts.version) {
            return version();
        }
        if (opts.interactive) {
            return startRepl();
        }
        if (opts.stdio) {
            return compileStdio();
        }
        if (opts["eval"]) {
            ref1 = opts["eval"];
            for (i = 0, len = ref1.length; i < len; i++) {
                eval = ref1[i];
                compileScript(eval);
            }
            return;
        }
        if (!opts["arguments"].length) {
            return startRepl();
        }
        literals = opts.run ? opts["arguments"].splice(1) : [];
        process.argv = process.argv.slice(0, 2).concat(literals);
        process.argv[0] = 'koffee';
        if (opts.output) {
            opts.output = path.resolve(opts.output);
        }
        ref2 = opts["arguments"];
        results = [];
        for (j = 0, len1 = ref2.length; j < len1; j++) {
            source = ref2[j];
            source = path.resolve(source);
            if (opts.watch) {
                results.push(watchPath(source));
            } else {
                results.push(compilePath(source, true));
            }
        }
        return results;
    };

    exports.run = run;

    startRepl = function() {
        var replCliOpts;
        replCliOpts = {
            useGlobal: true
        };
        if (opts.require) {
            opts.prelude = makePrelude(opts.require);
        }
        replCliOpts.prelude = opts.prelude;
        return require('./repl').start(replCliOpts);
    };

    makePrelude = function(requires) {
        return requires.map(function(module) {
            var _, match, name;
            if (match = module.match(/^(.*)=(.*)$/)) {
                _ = match[0], name = match[1], module = match[2];
            }
            name || (name = helpers.baseFileName(module, true, useWinPathSep));
            return name + " = require('" + module + "')";
        }).join(';');
    };

    compilePath = function(source, topLevel) {
        var code, err, file, files, i, len, ref1, results, stats;
        if (topLevel == null) {
            topLevel = false;
        }
        if (!topLevel && hidden(source)) {
            return;
        }
        try {
            stats = fs.statSync(source);
        } catch (error1) {
            err = error1;
            if (err.code === 'ENOENT') {
                error("Command.compilePath can't stat '" + source + "'");
                process.exit(1);
            }
            throw err;
        }
        if (stats.isDirectory()) {
            if ((ref1 = path.basename(source)) === 'node_modules' || ref1 === '.git') {
                return;
            }
            if (opts.run) {
                compilePath(findDirectoryIndex(source), topLevel);
                return;
            }
            if (opts.Debug) {
                log('Command.compilePath dir:', source);
            }
            try {
                files = fs.readdirSync(source);
            } catch (error1) {
                err = error1;
                if (err.code === 'ENOENT') {
                    return;
                }
                throw err;
            }
            results = [];
            for (i = 0, len = files.length; i < len; i++) {
                file = files[i];
                results.push(compilePath(path.join(source, file)));
            }
            return results;
        } else if (topLevel || helpers.isCoffee(source)) {
            try {
                code = fs.readFileSync(source);
            } catch (error1) {
                err = error1;
                if (err.code === 'ENOENT') {
                    return;
                }
                throw err;
            }
            if (opts.Debug) {
                log('Command.compilePath file:', source);
            }
            return compileScript(code.toString(), source);
        }
    };

    findDirectoryIndex = function(source) {
        var err, ext, i, index, len, ref1;
        ref1 = Koffee.FILE_EXTENSIONS;
        for (i = 0, len = ref1.length; i < len; i++) {
            ext = ref1[i];
            index = path.join(source, "index" + ext);
            try {
                if ((fs.statSync(index)).isFile()) {
                    return index;
                }
            } catch (error1) {
                err = error1;
                if (err.code !== 'ENOENT') {
                    throw err;
                }
            }
        }
        error("Missing index.coffee in " + source);
        return process.exit(1);
    };

    compileScript = function(input, file) {
        var base, compiled, err, message, o, options, t, task;
        if (file == null) {
            file = null;
        }
        o = opts;
        options = compileOptions(file);
        try {
            t = task = {
                file: file,
                input: input,
                options: options
            };
            Koffee.emit('compile', task);
            if (o.tokens) {
                return printTokens(Koffee.tokens(t.input, t.options));
            } else if (o.nodes) {
                return printLine(Koffee.nodes(t.input, t.options).toString().trim());
            } else if (o.run) {
                Koffee.register();
                if (opts.prelude) {
                    Koffee["eval"](opts.prelude, t.options);
                }
                if ((base = t.options).filename == null) {
                    base.filename = options.source;
                }
                if (opts.noop) {
                    return log("noop run " + file);
                } else {
                    return Koffee.run(t.input, t.options);
                }
            } else {
                compiled = Koffee.compile(t.input, t.options);
                t.output = compiled;
                if (o.map) {
                    t.output = compiled.js;
                    t.sourceMap = compiled.v3SourceMap;
                }
                Koffee.emit('success', task);
                if (o.js) {
                    if (opts.noop) {
                        return log("noop js " + file);
                    } else {
                        return printLine(t.output.trim());
                    }
                } else if (o.compile || o.map) {
                    if (opts.noop) {
                        return log("noop write " + options.jsPath);
                    } else {
                        return writeJs(t.file, t.output, options.jsPath, t.sourceMap);
                    }
                }
            }
        } catch (error1) {
            err = error1;
            Koffee.emit('failure', err, task);
            if (Koffee.listeners('failure').length) {
                return;
            }
            message = (err != null ? err.stack : void 0) || ("" + err);
            if (o.watch) {
                return printLine(message + '\x07');
            } else {
                printWarn(message);
                return process.exit(1);
            }
        }
    };

    compileOptions = function(source) {
        var copts, cwd, jsDir, jsPath;
        copts = {
            source: source,
            sourceMap: opts.map,
            inlineMap: opts['inline-map'],
            feature: opts.feature,
            bare: opts.bare,
            Debug: opts.Debug
        };
        if (source) {
            cwd = process.cwd();
            jsPath = outputPath(source, '.js');
            jsDir = path.dirname(jsPath);
            copts = helpers.merge(copts, {
                jsPath: jsPath,
                sourceRoot: path.relative(jsDir, cwd),
                sourceFiles: [path.relative(cwd, source)],
                generatedFile: helpers.baseFileName(jsPath, false, useWinPathSep)
            });
        }
        return copts;
    };

    compileStdio = function() {
        var buffers, stdin;
        buffers = [];
        stdin = process.openStdin();
        stdin.on('data', function(buffer) {
            if (buffer) {
                return buffers.push(buffer);
            }
        });
        return stdin.on('end', function() {
            return compileScript(Buffer.concat(buffers).toString());
        });
    };

    watchPath = function(source) {
        var err, stats;
        try {
            stats = fs.statSync(source);
        } catch (error1) {
            err = error1;
            if (err.code === 'ENOENT') {
                return;
            }
            return error("Command.watchPath can't stat '" + source + "'", err);
        }
        if (stats.isDirectory()) {
            return watchDir(source);
        } else {
            return watchFile(source);
        }
    };

    watchFile = function(source) {
        var compileTimeout, err, prevStats, startWatcher, watcher;
        if (!helpers.isCoffee(source)) {
            return;
        }
        if (opts.Debug) {
            log('Command.watchFile', source);
        }
        watcher = null;
        prevStats = null;
        compileTimeout = null;
        startWatcher = function() {
            return watcher = fs.watch(source).on('change', function(change) {
                if (change !== 'change') {
                    return;
                }
                if (opts.Debug) {
                    log('Command.watchFile', change, source);
                }
                clearTimeout(compileTimeout);
                return compileTimeout = wait(25, function() {
                    return fs.stat(source, function(err, stats) {
                        if ((err != null ? err.code : void 0) === 'ENOENT') {
                            return watcher.close();
                        }
                        if (err) {
                            return error(err);
                        }
                        if (prevStats && stats.mtime.getTime() === prevStats.mtime.getTime() && stats.size === prevStats.size) {
                            return;
                        }
                        prevStats = stats;
                        return fs.readFile(source, function(err, code) {
                            if (err) {
                                return error(err);
                            }
                            if (opts.Debug) {
                                log('Command.watchFile compile', source);
                            }
                            return compileScript(code.toString(), source);
                        });
                    });
                });
            }).on('error', function(err) {
                if (err.code !== 'EPERM') {
                    throw err;
                }
            });
        };
        try {
            return startWatcher();
        } catch (error1) {
            err = error1;
            return error(err);
        }
    };

    watchDir = function(source) {
        var err, startWatcher, watcher;
        if (opts.Debug) {
            log('Command.watchDir', source);
        }
        watcher = null;
        startWatcher = function() {
            var err, file, files, i, len;
            try {
                files = fs.readdirSync(source);
            } catch (error1) {
                err = error1;
                if ((err != null ? err.code : void 0) === 'ENOENT') {
                    return;
                }
                throw err;
            }
            for (i = 0, len = files.length; i < len; i++) {
                file = files[i];
                if (file[0] === '.') {
                    continue;
                }
                if (file === 'node_modules') {
                    continue;
                }
                watchPath(path.join(source, file));
            }
            return watcher = fs.watch(source).on('error', function(err) {
                if (err.code !== 'EPERM') {
                    throw err;
                }
                return watcher.close();
            }).on('change', function(change, p) {
                if (change === 'rename') {
                    if (opts.Debug) {
                        log('Command.watchDir', change, path.join(source, p));
                    }
                    return watchPath(path.join(source, p));
                }
            });
        };
        try {
            return startWatcher();
        } catch (error1) {
            err = error1;
            if (err.code === 'ENOENT') {
                return;
            }
            throw err;
        }
    };

    outputPath = function(source, extension) {
        var basename, dir;
        basename = helpers.baseFileName(source, true, useWinPathSep);
        if (opts.output) {
            dir = opts.output;
        } else {
            dir = path.dirname(source);
        }
        return path.join(dir, basename + extension);
    };

    mkdirp = function(dir, fn) {
        var mkdirs, mode;
        mode = 0x1ff & ~process.umask();
        return (mkdirs = function(p, fn) {
            return fs.exists(p, function(exists) {
                if (exists) {
                    return fn();
                } else {
                    return mkdirs(path.dirname(p), function() {
                        return fs.mkdir(p, mode, function(err) {
                            if (err) {
                                return fn(err);
                            }
                            return fn();
                        });
                    });
                }
            });
        })(dir, fn);
    };

    writeJs = function(source, js, jsPath, generatedSourceMap) {
        var compile, jsDir, sourceMapPath;
        if (generatedSourceMap == null) {
            generatedSourceMap = null;
        }
        sourceMapPath = outputPath(source, '.js.map');
        jsDir = path.dirname(jsPath);
        compile = function() {
            if (opts.compile) {
                if (js.length <= 0) {
                    js = ' ';
                }
                if (generatedSourceMap) {
                    js = js + "\n//# sourceMappingURL=" + (helpers.baseFileName(sourceMapPath, false, useWinPathSep)) + "\n";
                }
                fs.writeFile(jsPath, js, function(err) {
                    if (err) {
                        printLine(err.message);
                        return process.exit(1);
                    } else if (opts.compile && opts.watch) {
                        return timeLog("compiled " + source);
                    }
                });
            }
            if (generatedSourceMap) {
                return fs.writeFile(sourceMapPath, generatedSourceMap, function(err) {
                    if (err) {
                        printLine("Could not write source map: " + err.message);
                        return process.exit(1);
                    }
                });
            }
        };
        return fs.exists(jsDir, function(itExists) {
            if (itExists) {
                return compile();
            } else {
                return mkdirp(jsDir, compile);
            }
        });
    };

    wait = function(milliseconds, func) {
        return setTimeout(func, milliseconds);
    };

    timeLog = function(message) {
        return log(((new Date).toLocaleTimeString()) + " - " + message);
    };

    printTokens = function(tokens) {
        var i, index, ref1, results, tag, token, value;
        results = [];
        for (index = i = 0, ref1 = tokens.length; 0 <= ref1 ? i < ref1 : i > ref1; index = 0 <= ref1 ? ++i : --i) {
            token = tokens[index];
            tag = token[0];
            value = token[1].toString().replace(/\n/, '\\n');
            if (tag === 'TERMINATOR') {
                results.push(print('\n\n'));
            } else if (tag === 'INDENT') {
                results.push(print('IND '));
            } else if (tag === 'OUTDENT') {
                results.push(print('OUT '));
            } else if (tag === 'CLASS' || tag === 'PARAM_START' || tag === 'PARAM_END' || tag === 'NULL') {
                results.push(print(index + " " + tag + " "));
            } else if (tag === value) {
                results.push(print(index + " " + tag + " "));
            } else {
                results.push(print(index + " " + tag + "=" + value + " "));
            }
        }
        return results;
    };

    version = function() {
        return printLine("" + Koffee.VERSION);
    };

    usage = function() {
        var lines, rules;
        lines = [BANNER + "\n"];
        rules = SWITCHES.map(function(rule) {
            var description, letter, long, longFlag, match, option, short;
            if (rule.length < 3) {
                rule.unshift(null);
            }
            short = rule[0], long = rule[1], description = rule[2];
            match = long.match(/\[(\w+(\*?))\]/);
            longFlag = long.match(/^(--\w[\w\-]*)/)[1];
            letter = short ? short + ', ' : '    ';
            option = helpers.pad(letter + long);
            return lines.push('    ' + option + description);
        });
        return log("\n" + (lines.join('\n')) + "\n");
    };

    features = function() {
        var f;
        f = function(f) {
            return "    " + (helpers.pad(f[0])) + f[1];
        };
        return log("\nFeatures:\n\n" + (FEATURES.map(f).join('\n')) + "\n");
    };

}).call(this);
