require('../../lib/helpers').initTest() if not global.test

test "named function parameters", ->
    
    (({a:x=666, b:y=777}) ->
        eq x, 1
        eq y, 777
    ) a:1
    
    (({a:a=666, b:b=777}) ->
        eq a, 666
        eq b, 2
    ) b:2

    (({a:a, b:b=777}) ->
        eq a, undefined
        eq b, 3
    ) b:3

    (({a:a, b:b=777}) ->
        eq a, undefined
        eq b, 777
    ) c:4
    
    (({a:a, b:b}) ->
        eq a, undefined
        eq b, 3
    ) b:3
    
test "named method parameters", ->
    
    class A
        @: ({a:a = 666, b:b = 777}) ->
            @a = a
            @b = b

    a = new A {}
    eq a.a, 666
    eq a.b, 777
            
    a = new A a:4
    eq a.a, 4
    eq a.b, 777
    
    a = new A b:5
    eq a.a, 666
    eq a.b, 5

    a = new A c:6
    eq a.a, 666
    eq a.b, 777
    
test "named method parameters assigned to this", ->
    
    class A
        @: ({a:@a = 666, b:@b = 777}) ->
    
    a = new A {}
    eq a.a, 666
    eq a.b, 777
            
    a = new A a:4
    eq a.a, 4
    eq a.b, 777
    
    a = new A b:5
    eq a.a, 666
    eq a.b, 5
    
    a = new A c:6
    eq a.a, 666
    eq a.b, 777

test "named method parameters get overridden in base", ->
    
    # the behavior of CS1 we want to avoid!

    class B
        @: ({a:@a = 555, b:@b = 777}) ->
        
    class A extends B
        @: ({a:@a = 666, c:@c = 888}) -> super
        
    a = new A {}
    eq a.a, 555 # this should be 666
    eq a.b, 777
    eq a.c, 888
            
    a = new A a:4
    eq a.a, 4
    eq a.b, 777
    eq a.c, 888
    
    a = new A b:5
    eq a.a, 555 # this should be 666
    eq a.b, 5
    eq a.c, 888
    
    a = new A c:6
    eq a.a, 555 # this should be 666
    eq a.b, 777
    eq a.c, 6
    
test "config parameters don't get overridden in base", ->

    # the behavior we want to achieve implemented in plain CS1

    class B
        @: ({a:@a = 555, b:@b = 777}) ->

    class A1 extends B
        @: ({a:a = 666, c:c = 888}) -> 
            arguments[0] = _.defaults {a:a, c:c}, arguments[0]
            super 
    
    a = new A1 {}
    eq a.a, 666
    eq a.b, 777
            
    a = new A1 a:4
    eq a.a, 4
    eq a.b, 777
    
    a = new A1 b:5
    eq a.a, 666
    eq a.b, 5
    
    a = new A1 c:6
    eq a.a, 666
    eq a.b, 777
            
    class A2 extends B
        @: ({a:@a = 666, c:@c = 888}) -> 
            arguments[0] = _.defaults {a:@a, c:@c}, arguments[0]
            super 
    
    a = new A2 {}
    eq a.a, 666
    eq a.b, 777
    eq a.c, 888
            
    a = new A2 a:4
    eq a.a, 4
    eq a.b, 777
    eq a.c, 888
    
    a = new A2 b:5
    eq a.a, 666
    eq a.b, 5
    eq a.c, 888
    
    a = new A2 c:6
    eq a.a, 666
    eq a.b, 777
    eq a.c, 6

test "config parameters don't modify argument", ->

    # make sure that the passed config dictionary doesn't get modified

    class B
        @: ({a:@a = 555, b:@b = 777}) ->

    class A extends B
        @: ({a:@a = 666, c:@c = 888}) -> 
            arguments[0] = _.defaults {a:@a, c:@c}, arguments[0]
            super 
    
    d = a:1, b:2, c:3
    a = new A d
    eq a.a, 1
    eq a.b, 2
    eq a.c, 3
    deepEqual d, a:1, b:2, c:3

    d = a:1, c:3
    a = new A d
    eq a.a, 1
    eq a.b, 777
    eq a.c, 3
    deepEqual d, a:1, c:3

    d = a:null, c:3
    a = new A d
    eq a.a, 666
    eq a.b, 777
    eq a.c, 3
    deepEqual d, a:null, c:3

    d = {}
    a = new A d
    eq a.a, 666
    eq a.b, 777
    eq a.c, 888
    deepEqual d, {}
    
test "config parameters are available in base", ->

    class B
        @: ({a:@a = 555, b:@b = 777}) ->
            eq @a, 1
            eq @b, 777
            eq @c, 888

    class A extends B
        @: ({a:@a = 666, c:@c = 888}) -> 
            arguments[0] = _.defaults {a:@a, c:@c}, arguments[0]
            super 
    
    new A a:1

test "config parameters shortcut", ->

    # instead of this ...
    # 
    # class A
    #       @: ({a: a=1, b: b=2 })           -> arguments[0] = _.defaults {a:a, b:b}, arguments[0] ...
    #       a: ({a:@a=1, b: b=2 })           -> arguments[0] = _.defaults {a:@a, b:b}, arguments[0] ...
    #       b: ({a:@a=1, b:@b=2 })           -> arguments[0] = _.defaults {a:@a, b:@b}, arguments[0] ...
    #       c: ({a: a=1, b:@b=2 })           -> arguments[0] = _.defaults {a:a, b:@b}, arguments[0] ...
    #       d: ({a: a=1, b: b=2 }, arg )     -> arguments[0] = _.defaults {a:a, b:b}, arguments[0] ...
    #       e: ({a: a=1, b: b=2 }, arg=1 )   -> arguments[0] = _.defaults {a:a, b:b}, arguments[0] ...
    #       f: ({a: a=1, b: b=2 }, arg=c:1 ) -> arguments[0] = _.defaults {a:a, b:b}, arguments[0] ...
    # 
    # ... it would be nice to just write ...
    #
    # class A
    #       @: (  a:1,  b:2 )          -> ...
    #       a: ( @a:1,  b:2 )          -> ...
    #       b: ( @a:1, @b:2 )          -> ...
    #       c: (  a:1, @b:2 )          -> ...
    #       d: (  a:1,  b:2, arg )     -> ...
    #       e: (  a:1,  b:2, arg=1 )   -> ...
    #       f: (  a:1,  b:2, arg=c:1 ) -> ...

